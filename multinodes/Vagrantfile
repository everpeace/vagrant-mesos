# -*- mode: ruby -*-
# vi: set ft=ruby :
require 'yaml'
require './lib/gen_node_infos'
require './lib/predicates'

base_dir = File.expand_path(File.dirname(__FILE__))
conf = YAML.load_file(File.join(base_dir, "cluster.yml"))
ninfos = gen_node_infos(conf)
ami = YAML.load_file(File.join(base_dir,"scripts","aws_region_ami.yaml"))

## vagrant plugins required:
# vagrant-aws, vagrant-berkshelf, vagrant-omnibus, vagrant-hosts, vagrant-cachier
Vagrant.configure("2") do |config|

  # enable plugins
  config.berkshelf.enabled = true
  config.omnibus.chef_version = :latest
  config.cache.auto_detect = true

  # define VMs. all VMs has identical configuration.
  [ninfos[:zk], ninfos[:master], ninfos[:slave]].flatten.each_with_index do |ninfo, i|
    config.vm.define ninfo[:hostname] do |cfg|


      config.vm.provider :vmware_fusion do |fusion,override|
        override.vm.box     = "precise64_vmware_fusion"
        override.vm.box_url = "http://files.vagrantup.com/precise64_vmware_fusion.box"

        override.vm.hostname = ninfo[:hostname]
        override.vm.network :private_network, :ip => ninfo[:ip]
        override.vm.provision :hosts

        fusion.name = 'vagrant-mesos-' + ninfo[:hostname]
#        fusion.customize ["modifyvm", :id, "--memory", ninfo[:mem], "--cpus", ninfo[:cpus] ]
        fusion.vmx["memsize"] = ninfo[:mem]
        fusion.vmx["numvcpus"] = ninfo[:cpus]

        override.vm.provision :shell do |s|
          s.path = "scripts/populate_sshkey.sh"
          s.args = "/root root"
        end

         override.vm.provision :shell do |s|
            s.path = "scripts/populate_sshkey.sh"
            s.args = "/home/vagrant vagrant"
         end
      end


      cfg.vm.provider :virtualbox do |vb, override|
        override.vm.box = "Official Ubuntu 13.04 daily Cloud Image amd64 (No Guest Additions)"
        override.vm.box_url = "http://cloud-images.ubuntu.com/vagrant/raring/current/raring-server-cloudimg-amd64-vagrant-disk1.box"

        override.vm.hostname = ninfo[:hostname]
        override.vm.network :private_network, :ip => ninfo[:ip]
        override.vm.provision :hosts

        vb.name = 'vagrant-mesos-' + ninfo[:hostname]
        vb.customize ["modifyvm", :id, "--memory", ninfo[:mem], "--cpus", ninfo[:cpus] ]

        override.vm.provision :shell do |s|
          s.path = "scripts/populate_sshkey.sh"
          s.args = "/root root"
        end

        override.vm.provision :shell do |s|
          s.path = "scripts/populate_sshkey.sh"
          s.args = "/home/vagrant vagrant"
        end
      end


      cfg.vm.provider :aws do |aws, override|
        override.vm.box = "dummy"
        override.vm.box_url = "https://github.com/mitchellh/vagrant-aws/raw/master/dummy.box"

        aws.access_key_id = conf["access_key_id"]
        aws.secret_access_key = conf["secret_access_key"]

        aws.region = conf["region"]
        aws.ami = ami[conf["region"]]
        aws.instance_type = ninfo[:instance_type]
        aws.keypair_name = conf["keypair_name"]
        aws.subnet_id = conf["subnet_id"]
        aws.security_groups = conf["security_groups"]
        aws.private_ip_address = ninfo[:ip]
        aws.tags = {
          Name: "vagrant-mesos-#{ninfo[:hostname]}"
        }
        if conf[:default_vpc] then
          aws.elastic_ip = true
        end

        override.ssh.username = "ubuntu"
        override.ssh.private_key_path = conf["ssh_private_key_path"]

        override.vm.provision :shell do |s|
          s.path = "scripts/populate_sshkey.sh"
          s.args = "/home/ubuntu ubuntu"
        end

        if master?(ninfo[:hostname]) || slave?(ninfo[:hostname]) then
          override.vm.provision :shell , :inline => <<SCRIPT
            PUBLIC_DNS=`wget -q -O - http://169.254.169.254/latest/meta-data/public-hostname`
            hostname $PUBLIC_DNS
            echo $PUBLIC_DNS > /etc/hostname
            HOSTNAME=$PUBLIC_DNS  # Fix the bash built-in hostname variable too
SCRIPT
        end

        if master?(ninfo[:hostname]) then
          override.vm.provision :shell , :inline => 'restart mesos-master'
        end

        if slave?(ninfo[:hostname]) then
          override.vm.provision :shell , :inline => 'restart mesos-slave'
        end
      end

      cfg.vm.provision :chef_solo do |chef|
#       chef.log_level = :debug
        chef.add_recipe "apt"
        chef.add_recipe "mesos"

        if master?(ninfo[:hostname]) then
          chef.add_recipe "mesos::master"
          chef.json  = {
            :mesos=> {
              :type         => "mesosphere",
              :version      => conf[:mesos_version],
              :master_ips   => ninfos[:master].map { |m| "#{m[:ip]}" },
              :slave_ips    => ninfos[:slave].map { |s| "#{s[:ip]}" },
              :master       => if ninfos[:zk].length > 0 then
                {
                  :cluster => "MyCluster",
                  :zk => "zk://"+ninfos[:zk].map{|zk| zk[:ip]+":2181"}.join(", ")+"/mesos",
                  :ip => "#{ninfo[:ip]}"
                }
              else
                {
                  :cluster => "MyCluster",
                  :ip => "#{ninfo[:ip]}"
                }
              end
            }
          }
        elsif slave?(ninfo[:hostname]) then
          chef.add_recipe "docker::aufs"
          chef.add_recipe "docker::lxc"
          chef.add_recipe "docker"
          chef.add_recipe "mesos::slave"
          chef.add_recipe "mesos::docker-executor"
          chef.json = {
            :mesos => {
              :type         => "mesosphere",
              :version      => conf[:mesos_version],
              :slave        => {
                :master       => if ninfos[:zk].length > 0 then
                                   "zk://"+ninfos[:zk].map{|zk| zk[:ip]+":2181"}.join(", ")+"/mesos"
                                 else
                                   "#{ninfos[:master][0][:ip]}:5050"
                                 end,
                :ip           => "#{ninfo[:ip]}",
                :isolation    => "process"
              }
            }
          }
        elsif zk?(ninfo[:hostname]) then
          chef.json = {
            :mesos => {
              :type         => "mesosphere",
              :version      => conf[:mesos_version],
              :mesosphere   => {
                :with_zookeeper => true
              }
            }
          }
        end
      end

      if zk?(ninfo[:hostname]) then
        myid = (/zk([0-9]+)/.match ninfo[:hostname])[1]
        cfg.vm.provision :shell, :inline => <<SCRIPT
          sudo mkdir -p /tmp/zookeeper
          sudo chmod 755 /tmp/zookeeper
          sudo chown zookeeper /tmp/zookeeper
          sudo -u zookeeper echo #{myid} > /tmp/zookeeper/myid
          sudo -u zookeeper /opt/chef/embedded/bin/ruby /vagrant/scripts/gen_zoo_conf.rb > /etc/zookeeper/conf/zoo.cfg
          sudo restart zookeeper
SCRIPT
      end
    end
  end

  if conf["marathon_enable"] then
    config.vm.define :marathon do |cfg|
      marathon_ip = conf["marathon_ipbase"]+"11"

      config.vm.provider :vmware_fusion do |fusion,override|
        override.vm.box     = "precise64_vmware_fusion"
        override.vm.box_url = "http://files.vagrantup.com/precise64_vmware_fusion.box"

        override.vm.hostname = "marathon"
        override.vm.network :private_network, :ip => marathon_ip
        override.vm.provision :hosts

        fusion.name = 'vagrant-mesos-' + "marathon"
#        fusion.customize ["modifyvm", :id, "--memory", ninfo[:mem], "--cpus", ninfo[:cpus] ]
        fusion.vmx["memsize"] = conf["marathon_mem"]
        fusion.vmx["numvcpus"] = conf["marathon_cpus"]

        override.vm.provision :shell do |s|
          s.path = "scripts/populate_sshkey.sh"
          s.args = "/root root"
        end

         override.vm.provision :shell do |s|
            s.path = "scripts/populate_sshkey.sh"
            s.args = "/home/vagrant vagrant"
         end
      end


      cfg.vm.provider :virtualbox do |vb, override|
        override.vm.box = "Official Ubuntu 13.04 daily Cloud Image amd64 (No Guest Additions)"
        override.vm.box_url = "http://cloud-images.ubuntu.com/vagrant/raring/current/raring-server-cloudimg-amd64-vagrant-disk1.box"

        override.vm.hostname = "marathon"
        override.vm.network :private_network, :ip => marathon_ip
        override.vm.provision :hosts

        vb.name = 'vagrant-mesos-' + "marathon"
        vb.customize ["modifyvm", :id, "--memory", conf["marathon_mem"], "--cpus", conf["marathon_cpus"] ]

        override.vm.provision :shell do |s|
          s.path = "scripts/populate_sshkey.sh"
          s.args = "/root root"
        end

        override.vm.provision :shell do |s|
          s.path = "scripts/populate_sshkey.sh"
          s.args = "/home/vagrant vagrant"
        end
      end


      cfg.vm.provider :aws do |aws, override|
        override.vm.box = "dummy"
        override.vm.box_url = "https://github.com/mitchellh/vagrant-aws/raw/master/dummy.box"

        aws.access_key_id = conf["access_key_id"]
        aws.secret_access_key = conf["secret_access_key"]

        aws.region = conf["region"]
        aws.ami = ami[conf["region"]]
        aws.instance_type = conf["marathon_instance_type"]
        aws.keypair_name = conf["keypair_name"]
        aws.subnet_id = conf["subnet_id"]
        aws.security_groups = conf["security_groups"]
        aws.private_ip_address = marathon_ip
        aws.tags = {
          Name: "vagrant-mesos-marathon"
        }
        if conf[:default_vpc] then
          aws.elastic_ip = true
        end

        override.ssh.username = "ubuntu"
        override.ssh.private_key_path = conf["ssh_private_key_path"]

        override.vm.provision :shell do |s|
          s.path = "scripts/populate_sshkey.sh"
          s.args = "/home/ubuntu ubuntu"
        end

        override.vm.provision :shell , :inline => <<SCRIPT
          PUBLIC_DNS=`wget -q -O - http://169.254.169.254/latest/meta-data/public-hostname`
          hostname $PUBLIC_DNS
          echo $PUBLIC_DNS > /etc/hostname
          HOSTNAME=$PUBLIC_DNS  # Fix the bash built-in hostname variable too
SCRIPT
      end

      cfg.vm.provision :chef_solo do |chef|
        chef.add_recipe "apt"
        chef.add_recipe "mesos"
        chef.json = {
          :mesos => {
            :type         => "mesosphere",
            :version      => conf[:mesos_version]
          }
        }
      end

      cfg.vm.provision :shell, :inline => <<SCRIPT
        apt-get -y install default-jre-headless unzip curl libcurl3
        if [ ! -e /tmp/marathon.tgz ]; then
          curl -sSfL http://downloads.mesosphere.io/marathon/marathon-0.4.1.tgz --output /tmp/marathon.tgz
          mkdir -p /opt && cd /opt && tar xzf /tmp/marathon.tgz
        fi
        kill -KILL `ps augwx | grep marathon | tr -s " " | cut -d' ' -f2`
        LIBPROCESS_IP=#{marathon_ip} nohup /opt/marathon/bin/start --master #{"zk://"+ninfos[:zk].map{|zk| zk[:ip]+":2181"}.join(",")+"/mesos"} --zk_hosts #{ninfos[:zk].map{|zk| zk[:ip]+":2181"}.join(",")} > /opt/marathon/nohup.log 2> /opt/marathon/nohup.log < /dev/null &
SCRIPT
    end
  end
end
